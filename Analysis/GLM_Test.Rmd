---
title: "GLM for BSA Testing"
author: "Cassandra Buzby"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

#Load packages
library(ggplot2)
library(tidyr)
library(tidyverse)
library(reshape2)
library(cowplot)

library(foreach)
library(doParallel)

#ggplot2::theme_set(theme_light())
ggplot2::theme_set(theme_cowplot())


CBchromPalette <- c("#F26430", "#0A369D", "#7EA3CC","#FF9F1C", "#C14953","#92DCE5", "#8FC93A","#4C4C47", 
                   "#F26430", "#0A369D", "#7EA3CC","#FF9F1C", "#C14953","#92DCE5", "#8FC93A","#4C4C47",
                  "#F26430", "#0A369D", "#7EA3CC")


library("QTLseqr")

ChromKey <- data.frame(chromosomes = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"), 
                       CHROM = c("NC_001133.9", "NC_001134.8", "NC_001135.5", "NC_001136.10", 
                                 "NC_001137.3", "NC_001138.5", "NC_001139.9", "NC_001140.6", 
                                 "NC_001141.2", "NC_001142.9", "NC_001143.9", "NC_001144.5", 
                                 "NC_001145.3", "NC_001146.8", "NC_001147.6", "NC_001148.4", "NC_001224.1"))

setwd("C:/Users/cassa/OneDrive/Documents/GitHub/Sequencing/Analysis")
#load("SAUA_4-13-22.Rdata")
#load("SCUC_4-13-22.Rdata")

load("SAUAwithChrI.Rdata")
load("SCUCwithChrI.Rdata")

#load("Selected_4-13-22.Rdata")
#load("Unselected_4-13-22.Rdata")

```

## Testing Mark's GLM idea for stats on BSA

### Mark's Simulation

Original code copied below; not evaluated but included for reference.

```{r, eval = FALSE}
set.seed(12345)
sim <- 100        # number of simulations
C <- 2000           # mean sequencing coverage
p <- 0.5            # probability of inheriting oak allele
additive_odds <-  1.1  # odds ratio of getting oak allele in selected bulk (regardless of chr 1 parent)
epistatic_odds <- 1.2  # odds ratio of getting oak allele in selected bulk from oak chr 1 vs. wine chr 1
# initialize data frame to hold simulation statistics:
sim_df <- data.frame(P_intercept = double(),P_bulk = double(),P_parent = double(),P_interaction = double(),
                     z_intercept = double(),z_bulk = double(),z_parent = double(),z_interaction = double())

# GIVEN THESE PARAMETERS, THE PROBABILITY OF GETTING THE OAK ALLELE IN EACH BULK IS:
p_unselected_wineChr1 <- p
p_unselected_oakChr1 <- p
p_selected_wineChr1 <- p * additive_odds / (1 - p + p * additive_odds)
p_selected_oakChr1 <- p_selected_wineChr1 * epistatic_odds /
                      (1 - p_selected_wineChr1 + p_selected_wineChr1 * epistatic_odds)

# RUN SIMULATIONS:
C_unselected_wineChr1 <- rpois(sim,C) # number of reads from unselected bulk from wine chromosome 1 cross
C_unselected_oakChr1 <- rpois(sim,C)  # number of reads from unselected bulk from oak chromosome 1 cross
C_selected_wineChr1 <- rpois(sim,C)   # number of reads from selected bulk from wine chromosome 1 cross
C_selected_oakChr1 <- rpois(sim,C)    # number of reads from selected bulk from oak chromosome 1 cross

for (i in 1:sim) {
  # SAMPLE READS FROM EACH BULK
  reads_unselected_wineChr1 <- sample(c("wine","oak"),C_unselected_wineChr1[i],replace=TRUE,
                                      prob=c(1-p_unselected_wineChr1,p_unselected_wineChr1))
  reads_unselected_oakChr1 <- sample(c("wine","oak"),C_unselected_oakChr1[i],replace=TRUE,
                                      prob=c(1-p_unselected_oakChr1,p_unselected_oakChr1))
  reads_selected_wineChr1 <- sample(c("wine","oak"),C_selected_wineChr1[i],replace=TRUE,
                                      prob=c(1-p_selected_wineChr1,p_selected_wineChr1))
  reads_selected_oakChr1 <- sample(c("wine","oak"),C_selected_oakChr1[i],replace=TRUE,
                                     prob=c(1-p_selected_oakChr1,p_selected_oakChr1))
  reads_df <- data.frame(reads = factor(c(reads_unselected_wineChr1,
                                          reads_unselected_oakChr1,
                                          reads_selected_wineChr1,
                                          reads_selected_oakChr1),levels = c("wine","oak")))
  reads_df$bulk <- factor(rep(c("unselected","selected"),
                              c(C_unselected_wineChr1[i]+C_unselected_oakChr1[i],
                                C_selected_wineChr1[i]+C_selected_oakChr1[i])),
                         levels = c("unselected","selected"))
  reads_df$parent <- factor(rep(c("wineChr1","oakChr1","wineChr1","oakChr1"),
                                c(C_unselected_wineChr1[i],C_unselected_oakChr1[i],
                                  C_selected_wineChr1[i],C_selected_oakChr1[i])),
                         levels = c("wineChr1","oakChr1"))
  # NOW DO LOGISTIC REGRESSION
  log_reg <- glm(reads ~ bulk + parent + bulk:parent,family=binomial,data=reads_df)
  sim_df[i,] <- c(coef(summary(log_reg))[,4],coef(summary(log_reg))[,3])
}
```

So the output of this is... a list of either oak or wine at every location, and then the glm looks at that by two other columns. So if I just have the counts for each and not the individual reads, would that work?

## Converting SAUA and SCUC into the correct format for glm

```{r, eval = FALSE}
AllSU <- inner_join(SCUC, SAUA, by = c("POS", "CHROM"), suffix = c(".Wine", ".Oak"))

AllSU %>% select(CHROM, POS, 
                 AD_REF.LOW.Wine, AD_ALT.LOW.Wine, AD_REF.HIGH.Wine, AD_ALT.HIGH.Wine,
                 AD_REF.LOW.Oak, AD_ALT.LOW.Oak, AD_REF.HIGH.Oak, AD_ALT.HIGH.Oak) -> RefAltSU

RefAltSU %>% pivot_longer(-c(CHROM, POS)) %>% mutate(allele = gsub(x = name, pattern = "AD_(.[A-Z]*).*", replacement = "\\1")) %>% 
  mutate(bulk = gsub(x = name, pattern = "AD_([A-Z]*).([A-Z]*).*", replacement = "\\2")) %>% 
  mutate(parent = gsub(x = name, pattern = "AD_([A-Z]*).([A-Z]*).(*)", replacement = "\\3")) %>% select(-name) -> RASU_Pivot

# gsub(x = RASU_Pivot[1,"name"], pattern = "AD_(.[A-Z]*).*", replacement = "\\1") #
# gsub(x = RASU_Pivot[2,"name"], pattern = "AD_([A-Z]*).([A-Z]*).*", replacement = "\\2")
# gsub(x = RASU_Pivot[2,"name"], pattern = "AD_([A-Z]*).([A-Z]*).(*)", replacement = "\\3")

RASU_Pivot$allele <- factor(RASU_Pivot$allele)
RASU_Pivot$bulk <- factor(RASU_Pivot$bulk, levels = c("LOW", "HIGH"))
RASU_Pivot$parent <- factor(RASU_Pivot$parent)

head(RASU_Pivot)

save(RASU_Pivot, file = "RASU_Pivot_plusChrI.Rdata")
```

```{r}
load("RASU_Pivot.Rdata")
```


# Adding in the parental loci

```{r}
read.table("Wine_VCF.txt", header = TRUE) %>% mutate(parent = "Wine") -> WineTemp
read.table("Oak_VCF.txt", header = TRUE) %>% mutate(parent = "Oak") -> OakTemp

ParentalVCF <- rbind(WineTemp, OakTemp) %>% arrange(CHROM, POS) %>% select(CHROM, POS, REF, ALT, parent) %>% merge(ChromKey) %>% select(-CHROM) %>% mutate(CHROM = chromosomes) %>% select(-chromosomes)

ParentalVCF %>% pivot_wider(names_from = parent, values_from = ALT) -> SNPids

SNPids$Type <- NA
SNPids$Type[is.na(SNPids$Wine) == TRUE] <- "Oak"
SNPids$Type[is.na(SNPids$Oak) == TRUE] <- "Wine"
SNPids$Type[SNPids$Wine == SNPids$Oak] <- "Alt"

SNPids[is.na(SNPids$Type),]

ggplot(SNPids, aes(x = Type, fill = Type)) + geom_bar() + ggtitle("Number of Variant Alleles")
```
```{r, eval = FALSE}
RASU_Pivot %>% merge(SNPids) -> ReadsParental

save(ReadsParental, file = "ReadsParental_plusChrI.Rdata")
```


## Which parent is which in the glm?

```{r, eval = FALSE}
load("ReadsParental_plusChrI.Rdata")

ReadsParental %>% filter(CHROM == "VIII") %>% ggplot(., aes(x = POS, y = value, color = Type)) + 
    scale_color_manual(values = c("black", "blue","firebrick", "gray")) + 
  geom_point(alpha = 0.1) + facet_grid(~bulk+allele) + ggtitle("Chr VIII")

ReadsParental %>% filter(CHROM == "VII") %>% ggplot(., aes(x = POS, y = value, color = Type)) +     
    scale_color_manual(values = c("black", "blue","firebrick", "gray")) + 
  geom_point(alpha = 0.1) + facet_grid(~bulk+allele) + ggtitle("Chr VII")


```

### Picking out just the effects of the high bulks

By dividing the alternate by the reference, the allele which is labeled as "Type" (ie the alternative) effect indicates which allele is the driving mutation.

```{r}
load("ReadsParental_plusChrI.Rdata")

# RASU_Pivot %>% filter(CHROM == "VIII", bulk == "HIGH") %>% pivot_wider(names_from = allele) %>% 
#   ggplot(., aes(x = REF, y = ALT, color = parent)) + 
#     scale_color_manual(values = c("lightblue", "firebrick")) + 
#   geom_point(alpha = 0.1)  + ggtitle("Chr VIII")
# 
# RASU_Pivot %>% filter(CHROM == "VII", bulk == "HIGH") %>% pivot_wider(names_from = allele) %>% 
#   ggplot(., aes(x = REF, y = ALT, color = parent)) + 
#     scale_color_manual(values = c("lightblue", "firebrick")) + 
#   geom_point(alpha = 0.1)  + ggtitle("Chr VII")

# RASU_Pivot %>% filter(CHROM == "VIII", bulk == "HIGH") %>% pivot_wider(names_from = allele) %>% 
#   ggplot(., aes(x = POS, y = ALT/REF, color = parent)) + 
#     scale_color_manual(values = c("lightblue", "firebrick")) + 
#   geom_point(alpha = 0.5)  + ggtitle("Chr VIII")
# 
# RASU_Pivot %>% filter(CHROM == "VII", bulk == "HIGH") %>% pivot_wider(names_from = allele) %>% 
#   ggplot(., aes(x = POS, y = ALT/REF, color = parent)) + 
#     scale_color_manual(values = c("lightblue", "firebrick")) + 
#   geom_point(alpha = 0.5)  + ggtitle("Chr VII")

ReadsParental %>% filter(CHROM == "VIII") %>% select(-Wine, -Oak, -REF) %>% pivot_wider(names_from = allele, values_from = value) %>% 
  ggplot(., aes(x = POS, y = ALT/REF, color = Type)) + 
    scale_color_manual(values = c("black", "blue","firebrick", "gray")) + 
  geom_point(alpha = 0.5)  + facet_grid(~bulk) + ggtitle("Chr VIII")

ReadsParental %>% filter(CHROM == "VII") %>% select(-Wine, -Oak, -REF) %>% pivot_wider(names_from = allele, values_from = value) %>% 
  ggplot(., aes(x = POS, y = ALT/REF, color = Type)) + 
    scale_color_manual(values = c("black", "blue","firebrick", "gray")) + 
  geom_point(alpha = 0.5)  + facet_grid(~bulk) + ggtitle("Chr VII")

ReadsParental %>% filter(bulk == "HIGH") %>% select(-Wine, -Oak, -REF) %>% 
  pivot_wider(names_from = allele, values_from = value) -> ReadsWider
 
ggplot(ReadsWider, aes(x = POS, y = ALT/REF, color = Type)) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(ReadsWider$POS), 
                                  by = 10^(floor(log10(max(ReadsWider$POS))))), 
                    name = "Genomic Position") +
    scale_color_manual(values = c("black", "blue","firebrick", "gray")) + 
    theme(axis.text.x = element_blank()) +
  geom_point(alpha = 0.5)  + facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("High Bulk Allele Effects")
```




```{r}
load("ReadsParental_plusChrI.Rdata")

#Look at the difference between Alt and Oak/Wine in this plot vs above
ggplot(ReadsParental, aes(x = Type, fill = Type)) + geom_bar() + ggtitle("Number of Variant Alleles")
```

This is interesting because the number of positions that were called in each bulk amplifies the oak and wine alleles but not the alt alleles, which is good for keeping the most data of quality. 

```{r}
ReadsParental %>% filter(Type == "Alt") %>% ggplot(., aes(x = value, fill = allele)) + geom_density(alpha = 0.5, size = 1) + ggtitle("Alt vs Ref where Oak/Wine are Equivalent")

ReadsParental %>% filter(Type != "Alt") %>% ggplot(., aes(x = value, fill = allele)) + geom_density(alpha = 0.5, size = 1) + ggtitle("Alt vs Ref where Oak/Wine are not Equivalent")
```



```{r}
## Converting reference and alternate into oak and wine

load("ReadsParental_plusChrI.Rdata")

ReadsParental %>% filter(Type == "Oak" | Type == "Wine") -> logregParental

logregParental$reads[logregParental$allele == "ALT"] <- logregParental$Type[logregParental$allele == "ALT"]
logregParental$reads[logregParental$allele == "REF" & logregParental$Type == "Oak"] <- "Wine"
logregParental$reads[logregParental$allele == "REF" & logregParental$Type == "Wine"] <- "Oak"

logregParental$reads <- factor(logregParental$reads)
head(logregParental)
```

## Actually running glm on each position by oak and wine

Why does it keep giving the same answer???? Use this section to figure out what the output should be that is saved for a single glm()

```{r, eval = FALSE}

mynewglm <- function(reads, bulk, parent, value, data){
  result <- glm(reads~bulk*parent, weights = value, family = binomial, data = data)
  return(result$coefficients[1])
}

logregParental %>% select(CHROM, POS, value, reads, parent, bulk) %>% 
  filter(CHROM == "II") %>% head(.,32) %>%
  group_by(POS) %>% 
  summarise(mynewglm(reads, bulk, parent, value, data = .))

logregParental %>% select(CHROM, POS, value, reads, parent, bulk) %>% 
  filter(CHROM == "II") %>% head(.,32) -> testII

resII <- summary(glm(reads ~ bulk*parent, weights = value, family=binomial, data = testII))

#find the z statistic for these
resII$coefficients[,3]

```

## Trying parallelization because clearly does not work

Cool markdown tutorial: https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html 

```{r, eval = FALSE}
#install.packages("doParallel")

# Return a data frame
foreach (i=unique(testII$POS), .combine=rbind) %dopar% {
  c(sqrt(i), i*2)
}

#My actual data
results <- foreach (i=unique(testII$POS), .combine=rbind) %dopar% {
  res <- glm(reads ~ bulk*parent, weights = value, family = binomial, data = testII[testII$POS == i,])
  res$coefficients
}

```

## Running this with an entire chromosome instead of just... 32 lines

```{r}

logregParental %>% select(CHROM, POS, value, reads, parent, bulk) %>% 
  filter(CHROM == "II") -> CHRMII_logregP

CHRMIIResults <- foreach (i=unique(CHRMII_logregP$POS), .combine=rbind) %dopar% {
  res <- glm(reads ~ bulk*parent, weights = value, family = binomial, data = CHRMII_logregP[CHRMII_logregP$POS == i,])
  c(i, res$coefficients)
}

head(as.data.frame(CHRMIIResults))
```


## How long does it take to run this on all of the chromosomes at once? A minute?

This did not work, but it might be fine to do a for loop through the chromosomes...?

```{r, eval = FALSE}

for(k in unique(logregParental$CHROM)){
  logregParental %>% select(CHROM, POS, value, reads, parent, bulk) %>% filter(CHROM == k) -> CHRM_logregP

  Results <- foreach (i=unique(CHRM_logregP$POS), .combine=rbind) %dopar% {
    res <- glm(reads ~ bulk*parent, weights = value, family = binomial, data = CHRM_logregP[CHRM_logregP$POS == i,])
    c(k, i, res$coefficients)
  }
  
  Results <- as.data.frame(Results)

  assign(value = Results, x = paste("Results_", k, sep = ""))
}

Res_AllChr <- rbind(Results_I, Results_II, Results_III, Results_IV, Results_V, Results_VI, Results_VII, Results_VIII, Results_IX, Results_X, Results_XI, 
      Results_XII, Results_XIII, Results_XIV, Results_XV, Results_XVI)

rm(Results_I, Results_II, Results_III, Results_IV, Results_V, Results_VI, Results_VII, Results_VIII, Results_IX, Results_X, Results_XI, 
      Results_XII, Results_XIII, Results_XIV, Results_XV, Results_XVI)

save(Res_AllChr, file = "GLM_Results_All_plusChrI.Rdata")
```

## Running the null model of Alt/Ref with those that are the same between oak and wine

```{r}

for(k in unique(ReadsParental$CHROM)){
  ReadsParental %>% filter(Type == "Alt") %>% select(CHROM, POS, value, allele, parent, bulk) %>% filter(CHROM == k) -> logregAlt

  Results <- foreach (i=unique(logregAlt$POS), .combine=rbind) %dopar% {
    res <- glm(allele ~ bulk*parent, weights = value, family = binomial, data = logregAlt[logregAlt$POS == i,])
    c(k, i, res$coefficients)
    }
  Results <- as.data.frame(Results)

  assign(value = Results, x = paste("AltResults_", k, sep = ""))
}

AltResults <- rbind(AltResults_II, AltResults_III, AltResults_IV, AltResults_V, AltResults_VI, 
                    AltResults_VII, AltResults_VIII, AltResults_IX, AltResults_X, AltResults_XI, 
                    AltResults_XII, AltResults_XIII, AltResults_XIV, AltResults_XV, AltResults_XVI)

rm(Results,AltResults_II, AltResults_III, AltResults_IV, AltResults_V, AltResults_VI, 
                    AltResults_VII, AltResults_VIII, AltResults_IX, AltResults_X, AltResults_XI, 
                    AltResults_XII, AltResults_XIII, AltResults_XIV, AltResults_XV, AltResults_XVI)

AltResults$V2 <- as.numeric(AltResults$V2)
AltResults$`(Intercept)` <- as.numeric(AltResults$`(Intercept)`)
AltResults$bulkHIGH <- as.numeric(AltResults$bulkHIGH)
AltResults$parentWine <- as.numeric(AltResults$parentWine)
AltResults$`bulkHIGH:parentWine` <- as.numeric(AltResults$`bulkHIGH:parentWine`)


ggplot(AltResults, aes(x = `bulkHIGH:parentWine`, color = V1)) + geom_density()

ggplot(AltResults, aes(x = V2, y = `bulkHIGH:parentWine`)) + geom_point() + facet_grid(~V1) + ggtitle("Interactions in Alt Alleles")
ggplot(AltResults, aes(x = V2, y = bulkHIGH)) + geom_point() + facet_grid(~V1) + ggtitle("Bulk Effect in Alt Alleles")
ggplot(AltResults, aes(x = V2, y = parentWine)) + geom_point() + facet_grid(~V1) + ggtitle("Parent Effect in Alt Alleles")

```

## Initial plotting the results

Not included because later plots are more enlightening

```{r, eval = FALSE}
load("GLM_Results_All_plusChrI.Rdata")

Res_AllChr$V2 <- as.numeric(Res_AllChr$V2)
Res_AllChr$`(Intercept)` <- as.numeric(Res_AllChr$`(Intercept)`)
Res_AllChr$bulkHIGH <- as.numeric(Res_AllChr$bulkHIGH)
Res_AllChr$parentWine <- as.numeric(Res_AllChr$parentWine)
Res_AllChr$`bulkHIGH:parentWine` <- as.numeric(Res_AllChr$`bulkHIGH:parentWine`)


ggplot(Res_AllChr, aes(x = `bulkHIGH:parentWine`, color = V1)) + geom_density()

ggplot(Res_AllChr, aes(x = V2, y = `bulkHIGH:parentWine`)) + geom_point() +scale_x_continuous(breaks = seq(from = 0, to = max(Res_AllChr$V2),
                                  by = 1000),
                    name = "Genomic Position") + facet_grid(~V1, scales = "free_x", space = "free_x") + ggtitle("Interactions")
ggplot(Res_AllChr, aes(x = V2, y = bulkHIGH)) + geom_point() +scale_x_continuous(breaks = seq(from = 0, to = max(Res_AllChr$V2),
                                  by = 1000),
                    name = "Genomic Position") + facet_grid(~V1, scales = "free_x", space = "free_x") + ggtitle("Bulk Effect")
ggplot(Res_AllChr, aes(x = V2, y = parentWine)) + geom_point() +scale_x_continuous(breaks = seq(from = 0, to = max(Res_AllChr$V2),
                                  by = 1000),
                    name = "Genomic Position") + facet_grid(~V1, scales = "free_x", space = "free_x") + ggtitle("Parent Effect")
```

## Running all of this to capture the z score

This actually times out, so perhaps need to run with less in R memory or not as a for loop...?

Use summary(glm(reads~bulk*parent, weights = value, family = binomial)) for each chromosome, then merge together and plot the Z scores from this summary.

```{r, eval = FALSE}

for(k in unique(logregParental$CHROM)){
  logregParental %>% select(CHROM, POS, value, reads, parent, bulk) %>% filter(CHROM == k) -> CHRM_logregP

  Results <- foreach (i=unique(CHRM_logregP$POS), .combine=rbind) %dopar% {
    res <- summary(glm(reads ~ bulk*parent, weights = value, family = binomial, data = CHRM_logregP[CHRM_logregP$POS == i,]))
    c(k, i, res$coefficients[,3])
  }
  
  Results <- as.data.frame(Results)

  assign(value = Results, x = paste("Results_", k, sep = ""))
}

Res_Z_Chr <- rbind(Results_I, Results_II, Results_III, Results_IV, Results_V, Results_VI, Results_VII, Results_VIII, Results_IX, Results_X, Results_XI, 
      Results_XII, Results_XIII, Results_XIV, Results_XV, Results_XVI)

rm(Results, Results_I, Results_II, Results_III, Results_IV, Results_V, Results_VI, Results_VII, Results_VIII, Results_IX, Results_X, Results_XI, 
      Results_XII, Results_XIII, Results_XIV, Results_XV, Results_XVI)

Res_Z_Chr$V2 <- as.numeric(Res_Z_Chr$V2)
Res_Z_Chr$`(Intercept)` <- as.numeric(Res_Z_Chr$`(Intercept)`)
Res_Z_Chr$bulkHIGH <- as.numeric(Res_Z_Chr$bulkHIGH)
Res_Z_Chr$parentWine <- as.numeric(Res_Z_Chr$parentWine)
Res_Z_Chr$`bulkHIGH:parentWine` <- as.numeric(Res_Z_Chr$`bulkHIGH:parentWine`)

save(Res_Z_Chr, file = "Res_Z_Chr_plusChrI.Rdata")
```

```{r}
# Load in data produced above
load("Res_Z_Chr_plusChrI.Rdata")
#rm(Res_Z_Chr)

Res_Z_Chr$CHROM <- factor(Res_Z_Chr$V1, levels = ChromKey$chromosomes)

#ggplot(Res_Z_Chr, aes(x = `bulkHIGH:parentWine`, color = CHROM)) + geom_density()

ggplot(Res_Z_Chr, aes(x = V2, y = `bulkHIGH:parentWine`, color = CHROM)) + geom_line() + #geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(Res_Z_Chr$V2),
                                  by = 1000),
                    name = "Genomic Position") + scale_color_manual(values = CBchromPalette) +
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Interactions Z Score")

ggplot(Res_Z_Chr, aes(x = V2, y = bulkHIGH, color = CHROM)) + geom_line() + #geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(Res_Z_Chr$V2),
                                  by = 1000),
                    name = "Genomic Position") + 
  scale_color_manual(values = CBchromPalette) +
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Bulk Effect Z Score")

ggplot(Res_Z_Chr, aes(x = V2, y = parentWine, color = CHROM)) + geom_line() + #geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(Res_Z_Chr$V2),
                                  by = 1000),
                    name = "Genomic Position") + 
  scale_color_manual(values = CBchromPalette) + 
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Parent Effect Z Score")
```

## Alt Alleles

Some variants are called that do not differ between oak and wine parents, but do have reference and alternate alleles. Reference in this case means that the variant is de novo (unlikely) or that the sequence is misaligned. I figured that these variants could serve as a null for the chances of misalignment, since I would assume that this noise is equal between bulks and parental background.

Because there are so few data points, and because this data is not actually right, this might be a bad idea, but I included it anyways:

```{r}

for(k in unique(ReadsParental$CHROM)){
  ReadsParental %>% filter(Type == "Alt") %>% select(CHROM, POS, value, allele, parent, bulk) %>% filter(CHROM == k) -> logregAlt

  Results <- foreach (i=unique(logregAlt$POS), .combine=rbind) %dopar% {
    res <- summary(glm(allele ~ bulk*parent, weights = value, family = binomial, data = logregAlt[logregAlt$POS == i,]))
    c(k, i, res$coefficients[,3])
    }
  Results <- as.data.frame(Results)

  assign(value = Results, x = paste("AltZResults_", k, sep = ""))
}

AltZResults <- rbind(AltZResults_II, AltZResults_III, AltZResults_IV, AltZResults_V, AltZResults_VI, 
                    AltZResults_VII, AltZResults_VIII, AltZResults_IX, AltZResults_X, AltZResults_XI, 
                    AltZResults_XII, AltZResults_XIII, AltZResults_XIV, AltZResults_XV, AltZResults_XVI)

rm(AltZResults_II, AltZResults_III, AltZResults_IV, AltZResults_V, AltZResults_VI, 
                    AltZResults_VII, AltZResults_VIII, AltZResults_IX, AltZResults_X, AltZResults_XI, 
                    AltZResults_XII, AltZResults_XIII, AltZResults_XIV, AltZResults_XV, AltZResults_XVI)

AltZResults$V2 <- as.numeric(AltZResults$V2)
AltZResults$`(Intercept)` <- as.numeric(AltZResults$`(Intercept)`)
AltZResults$bulkHIGH <- as.numeric(AltZResults$bulkHIGH)
AltZResults$parentWine <- as.numeric(AltZResults$parentWine)
AltZResults$`bulkHIGH:parentWine` <- as.numeric(AltZResults$`bulkHIGH:parentWine`)
AltZResults$CHROM <- factor(AltZResults$V1, levels = ChromKey$chromosomes)

ggplot(AltZResults, aes(x = `bulkHIGH:parentWine`, color = CHROM)) + geom_density() + ggtitle("Alt Interaction Distribution") + scale_color_manual(values = CBchromPalette) 

ggplot(AltZResults, aes(x = V2, y = `bulkHIGH:parentWine`, color = CHROM)) + geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(AltZResults$V2),
                                  by = 1000),
                    name = "Genomic Position") + scale_color_manual(values = CBchromPalette) +
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Alt Interactions Z Score")

ggplot(AltZResults, aes(x = V2, y = bulkHIGH, color = CHROM)) + geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(AltZResults$V2),
                                  by = 1000),
                    name = "Genomic Position") + 
  scale_color_manual(values = CBchromPalette) +
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Alt Bulk Effect Z Score")

ggplot(AltZResults, aes(x = V2, y = parentWine, color = CHROM)) + geom_point(alpha = 0.4) + 
  scale_x_continuous(breaks = seq(from = 0, to = max(AltZResults$V2),
                                  by = 1000),
                    name = "Genomic Position") + 
  scale_color_manual(values = CBchromPalette) + 
  facet_grid(~CHROM, scales = "free_x", space = "free_x") + ggtitle("Alt Parent Effect Z Score")

```

## Introducing Windows for Smoothing Z-scores

Many of these scripts are out of date, so those that plot are the most updated.

```{r, eval = FALSE}

#First thing, looping over all points per chromosome is the way to do this, and using a function would also be best.
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("CHROM", "POS", "Intercept", "bulkHigh", "parentWine", "Interaction")


#Load function
WindowCB_Int <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
  
  df %>% arrange(CHROM, POS) -> df
    
  #FOR LOOP through chromosomes
  
  Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
    
    #add reverse of window to the front of the df, expand size by windowsize
        df[df$CHROM == k,]  %>% head(., windowsize) %>% arrange(-POS) %>% rbind(.,df[df$CHROM == k,]) -> dfnew
    #add reverse of window to the end of the df, expand size by another windowsize
        dfnew  %>% tail(., windowsize) %>% arrange(-POS) %>% rbind(dfnew,.) -> dfnew
              
        #FOR LOOP from original index 1 to original end index
          foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
            #save the median value from original index 1 to original end index
                res <- median(dfnew$Interaction[i-windowsize:i+windowsize])
                #print CHROM, index, POS, and median
                c(k,i, dfnew$POS[i], res)}
  
  }
  #rename everything once it's done
  
  Result <- as.data.frame(Result)
  colnames(Result) <- c("CHROM", "i", "POS", "Zprime")
  Result$POS <- as.numeric(Result$POS)
  Result$Zprime <- as.numeric(Result$Zprime)
  
  Result
}

#Test function with defaults
WindowCB_Int()

#See if this runs?
windowresults_interaction_III <- WindowCB_Int(df = subset(Res_Z_Chr, CHROM == "III"), windowsize = 100)

windowresults_interaction <- WindowCB_Int(df = Res_Z_Chr, windowsize = 100)

save(windowresults_interaction, file = "WindowInteractions_w100.Rdata")

```


```{r, eval = FALSE}
## Try plotting these to see what the window size should be?

load("WindowInteractions_w100.Rdata")
ggplot(windowresults_interaction, aes(x = POS, y = Zprime, color = CHROM)) + geom_line() + geom_hline(yintercept = 0, color = "gray") +
  scale_color_manual(values = CBchromPalette) + facet_grid(~CHROM, scales = "free")
```
## Redoing this to account for all columns

This function finds the median within the window of each Z score; it produces a more jagged line than I'd like, since the median isn't actually weighted. Next thing to do would be a kernel of sorts, but I have to learn more math to implement it.

```{r, eval = FALSE}
#First thing, looping over all points per chromosome is the way to do this, and using a function would also be best.
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("CHROM", "POS", "Intercept", "bulkHigh", "parentWine", "Interaction")


#Load function
WindowCB <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
  
  df %>% arrange(CHROM, POS) -> df
    
  #FOR LOOP through chromosomes
  
  Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
    
    #add reverse of window to the front of the df, expand size by windowsize
        df[df$CHROM == k,]  %>% head(., windowsize) %>% arrange(-POS) %>% rbind(.,df[df$CHROM == k,]) -> dfnew
    #add reverse of window to the end of the df, expand size by another windowsize
        dfnew  %>% tail(., windowsize) %>% arrange(-POS) %>% rbind(dfnew,.) -> dfnew
              
        #FOR LOOP from original index 1 to original end index
          foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
            #save the median value from original index 1 to original end index
                res_int <- median(dfnew$Interaction[i-windowsize:i+windowsize])
                res_bulk <- median(dfnew$bulkHigh[i-windowsize:i+windowsize])
                res_parent <- median(dfnew$parentWine[i-windowsize:i+windowsize])
                #print CHROM, index, POS, and median
                c(k,i, dfnew$POS[i], res_bulk, res_parent, res_int)}
  
  }
  #rename everything once it's done
  
  Result <- as.data.frame(Result)
  colnames(Result) <- c("CHROM", "i", "POS", "Zprime_Bulk", "Zprime_Parent", "Zprime_Int")
  Result$POS <- as.numeric(Result$POS)
  Result$Zprime_Bulk <- as.numeric(Result$Zprime_Bulk)
  Result$Zprime_Parent <- as.numeric(Result$Zprime_Parent)
  Result$Zprime_Int <- as.numeric(Result$Zprime_Int)
  
  Result
}

#Test function with defaults
#WindowCB()
```

## Run this new function on all of the data

```{r, eval = FALSE}
windowresults <- WindowCB(df = Res_Z_Chr, windowsize = 20)

windowresults$CHROM <- factor(windowresults$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

save(windowresults, file = "windowresults_w20.Rdata")
```

```{r, eval = FALSE}

load("windowresults_w20.Rdata")

ggplot(windowresults, aes(x = POS, y = Zprime_Bulk, color = CHROM)) + geom_point(alpha = 0.4) + #geom_line() + 
  ylim(-10, 10) + scale_color_manual(values = CBchromPalette) + geom_hline(yintercept = 0, color = "gray")+ 
  facet_grid(~CHROM, scales = "free") + ggtitle("Bulk Zprime")

ggplot(windowresults, aes(x = POS, y = Zprime_Parent, color = CHROM)) + geom_point(alpha = 0.4) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = CBchromPalette) + geom_hline(yintercept = 0, color = "gray")+ 
  facet_grid(~CHROM, scales = "free") + ggtitle("Parent Zprime")

ggplot(windowresults, aes(x = POS, y = Zprime_Int, color = CHROM)) + geom_point(alpha = 0.4) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = CBchromPalette) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Zprime")

```

### Look at Chr XII Specifically 

Code failed, try again later

```{r, eval = FALSE}

windowresults %>% filter(CHROM == "XII") %>% ggplot(., aes(x = POS, y = Zprime_Int, color = CHROM)) + geom_point(alpha = 0.4) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = CBchromPalette[11]) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Zprime")

windowresults %>% filter(CHROM == "XII") %>% 
  transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int) -> XIIZprime

XIIZprime$Stat <- "ZPrime"

# Comparing specific chromosomes
#colnames(Res_Z_Chr) <- c("V1", "V2", "Intercept", "bulkHigh", "parentWine", "Interaction", "CHROM")


# Res_Z_Chr %>% filter(CHROM == "XII") %>% arrange(V2) %>% 
#    transmute(CHROM = CHROM, POS = V2, Bulk = bulkHigh, Parent = parentWine, Int = Interaction, Stat = "Z") -> XIIZ

rbind(XIIZ, XIIZprime) %>% filter(POS < 20000) %>% ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.4) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = CBchromPalette) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime")
```

### Comparing all chromosomes

Original scripts to compare; this isn't relevant anymore since I figured out my dumb coding issue that made the first bunch be a smaller window size.


```{r, eval = FALSE}
windowresults %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes

# Comparing specific chromosomes
#colnames(Res_Z_Chr) <- c("V1", "V2", "Intercept", "bulkHigh", "parentWine", "Interaction", "CHROM")

#Get the original back to rename columns
rm(Res_Z_Chr)
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("A", "B", "C", "D", "E", "F")
Res_Z_Chr %>% transmute(CHROM = A, POS = B, Bulk = D, Parent = E, Int = F, Stat = "Z") -> Zs

#Merge datasets
rbind(Zs, Zprimes) -> AllZStats

AllZStats$CHROM <- factor(AllZStats$CHROM, levels = ChromKey$chromosomes)

AllZStats %>%  ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime")

AllZStats %>% filter(POS < 20000) %>% ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+ ylim(-2,2)+
  facet_wrap(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | POS < 20kb") + 
  theme_minimal() + theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

```

## Trying a new function without the additions of window on either end

Since the last function amplified the correlations that were within that first window, next I'll just start at 1 windowlength in so that there's real data in every window; it would cut off the ends but that might actually be fine since they're not supposed to be contributing much...?

```{r}
#First thing, looping over all points per chromosome is the way to do this, and using a function would also be best.
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("CHROM", "POS", "Intercept", "bulkHigh", "parentWine", "Interaction")


#Load function
WindowCB_beta <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
  
  df %>% arrange(CHROM, POS) -> df
    
  #FOR LOOP through chromosomes
  
  Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
    
        #add reorder by position
        df[df$CHROM == k,] %>% arrange(POS)  -> dfnew
    
        #FOR LOOP from original index 1 to original end index
          foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
            #save the median value from original index 1 to original end index
                res_int <- median(dfnew$Interaction[(i-windowsize):(i+windowsize)])
                res_bulk <- median(dfnew$bulkHigh[(i-windowsize):(i+windowsize)])
                res_parent <- median(dfnew$parentWine[(i-windowsize):(i+windowsize)])
                #print CHROM, index, POS, and median
                c(k,i, dfnew$POS[i], res_bulk, res_parent, res_int)}
  
  }
  #rename everything once it's done
  
  Result <- as.data.frame(Result)
  colnames(Result) <- c("CHROM", "i", "POS", "Zprime_Bulk", "Zprime_Parent", "Zprime_Int")
  Result$POS <- as.numeric(Result$POS)
  Result$Zprime_Bulk <- as.numeric(Result$Zprime_Bulk)
  Result$Zprime_Parent <- as.numeric(Result$Zprime_Parent)
  Result$Zprime_Int <- as.numeric(Result$Zprime_Int)
  
  Result
}
```

```{r, eval = FALSE}
#WindowCB_beta()

#Test function with defaults
betaresults <- WindowCB_beta(Res_Z_Chr, 30)

#Plot to see
betaresults %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes

# Comparing specific chromosomes
#colnames(Res_Z_Chr) <- c("V1", "V2", "Intercept", "bulkHigh", "parentWine", "Interaction", "CHROM")

Res_Z_Chr %>% transmute(CHROM = CHROM, POS = POS, Bulk = bulkHigh, Parent = parentWine, Int = Interaction, Stat = "Z") -> Zs

rbind(Zs, Zprimes) -> AllZStats

AllZStats$CHROM <- factor(AllZStats$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

save(AllZStats, file = "AllZStats.Rdata")

```

```{r}

load("AllZStats.Rdata")

AllZStats %>%  ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime")

AllZStats %>%  ggplot(., aes(x = POS, y = Bulk, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("violet", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Bulk Effect Z vs Zprime")

AllZStats %>%  ggplot(., aes(x = POS, y = Parent, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("darkorange", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Parent Effect Z vs Zprime")

#unique(AllZStats$Stat)

AllZStats %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor")


```

### Looking closer at the beginnings of each

Troubleshooting for a problem that has now been solved

```{r, eval = FALSE}

AllZStats %>% filter(POS < 20000) %>% ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+ ylim(-2,2)+
  facet_wrap(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | POS < 20kb") + 
  theme_minimal() + theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        )

AllZStats %>% filter(POS < 30000, CHROM == "XV") %>% ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.5, size = 2) + #geom_line() + 
  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+ ylim(-2,2)+
  facet_wrap(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | POS < 20kb") + 
  theme_minimal() + theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        )

#shape = first 30

AllZStats %>%  filter(POS < 30000, CHROM == "XV") %>% arrange(POS) -> TestXV

TestXV$Stat[1:30] <- "Excluded"

TestXV %>% ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.5, size = 2) + 
  geom_point(data = TestXV, aes(x = TestXV$POS[30], y = mean(TestXV$Int[1:60])), size = 5, color = "blue", shape = 1) + #geom_line() + 
  scale_color_manual(values = c("red", "lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+ ylim(-2,2)+
  facet_wrap(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | POS < 20kb") + 
  theme_minimal() + theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        )

plot(sort(TestXV$Int[TestXV$Stat == "Z"]))

```

# Changing the functions to means and kernels

### Using means instead of medians

```{r, eval = FALSE}
#First thing, looping over all points per chromosome is the way to do this, and using a function would also be best.
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("CHROM", "POS", "Intercept", "bulkHigh", "parentWine", "Interaction")

#Res_Z_Chr %>% transmute(CHROM = CHROM, POS = POS, Bulk = bulkHigh, Parent = parentWine, Int = Interaction, Stat = "Z") -> Zs
#save(Zs, file = "Zs.Rdata")


#Load function
WindowCB_mean <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
  
  df %>% arrange(CHROM, POS) -> df
    
  #FOR LOOP through chromosomes
  Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
    
        #add reorder by position
        df[df$CHROM == k,] %>% arrange(POS)  -> dfnew
    
        #FOR LOOP from original index 1 to original end index
          foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
            #save the median value from original index 1 to original end index
                res_int <- mean(dfnew$Interaction[(i-windowsize):(i+windowsize)])
                res_bulk <- mean(dfnew$bulkHigh[(i-windowsize):(i+windowsize)])
                res_parent <- mean(dfnew$parentWine[(i-windowsize):(i+windowsize)])
                #print CHROM, index, POS, and mean
                c(k,i, dfnew$POS[i], res_bulk, res_parent, res_int)}
  
  }
  #rename everything once it's done
  
  Result <- as.data.frame(Result)
  colnames(Result) <- c("CHROM", "i", "POS", "Zprime_Bulk", "Zprime_Parent", "Zprime_Int")
  Result$POS <- as.numeric(Result$POS)
  Result$Zprime_Bulk <- as.numeric(Result$Zprime_Bulk)
  Result$Zprime_Parent <- as.numeric(Result$Zprime_Parent)
  Result$Zprime_Int <- as.numeric(Result$Zprime_Int)
  
  Result
}

#Test function with defaults
results.mean <- WindowCB_mean(Res_Z_Chr, 30)

#Plot to see
results.mean %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes
load("Zs.Rdata")
rbind(Zs, Zprimes) -> MeanZStats

MeanZStats$CHROM <- factor(MeanZStats$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

save(MeanZStats, file = "MeanZStats.Rdata")

```

Plotting the mean function rather than median

```{r}
load("MeanZStats.Rdata")

MeanZStats %>%  ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | Means")

MeanZStats %>%  ggplot(., aes(x = POS, y = Bulk, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("violet", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Bulk Effect Z vs Zprime | Means")

MeanZStats %>%  ggplot(., aes(x = POS, y = Parent, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("darkorange", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Parent Effect Z vs Zprime | Means")

MeanZStats %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Means")
```


### Using the weighted means function

```{r}
#First thing, looping over all points per chromosome is the way to do this, and using a function would also be best.
load("Res_Z_Chr.Rdata")
colnames(Res_Z_Chr) <- c("CHROM", "POS", "Intercept", "bulkHigh", "parentWine", "Interaction")

#Res_Z_Chr %>% transmute(CHROM = CHROM, POS = POS, Bulk = bulkHigh, Parent = parentWine, Int = Interaction, Stat = "Z") -> Zs
#save(Zs, file = "Zs.Rdata")

# testfunction <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
#   
#   df %>% arrange(CHROM, POS) -> df
#   weightvector <- c(rep(1:(windowsize)), rep((windowsize):1))
#   Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
#     
#         #add reorder by position
#         df[df$CHROM == k,] %>% arrange(POS)  -> dfnew
#     
#         #FOR LOOP from original index 1 to original end index
#           foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
#             #save the median value from original index 1 to original end index
#                 print(length(dfnew$Interaction[(i-windowsize):(i+windowsize)]))
#           }
#   
#   }
# }
# 
# #testfunction()

#Load function
WindowCB_meanweighted <- function(df = Res_Z_Chr[1:20,], windowsize = 5){
  
  df %>% arrange(CHROM, POS) -> df
  weightvector <- c(rep(1:(windowsize)),windowsize+1, rep((windowsize):1))

  #FOR LOOP through chromosomes
  
  Result <- foreach (k=unique(df$CHROM), .combine=rbind) %dopar% {
    
        #add reorder by position
        df[df$CHROM == k,] %>% arrange(POS)  -> dfnew
    
        #FOR LOOP from original index 1 to original end index
          foreach(i=windowsize+1:(length(dfnew$POS) - (2*windowsize)), .combine=rbind) %dopar% {
            #save the median value from original index 1 to original end index
                res_int <- weighted.mean(dfnew$Interaction[(i-windowsize):(i+windowsize)], weightvector)
                res_bulk <- weighted.mean(dfnew$bulkHigh[(i-windowsize):(i+windowsize)], weightvector)
                res_parent <- weighted.mean(dfnew$parentWine[(i-windowsize):(i+windowsize)], weightvector)
                #print CHROM, index, POS, and mean
                c(k,i, dfnew$POS[i], res_bulk, res_parent, res_int)}
  
  }
  #rename everything once it's done
  
  Result <- as.data.frame(Result)
  colnames(Result) <- c("CHROM", "i", "POS", "Zprime_Bulk", "Zprime_Parent", "Zprime_Int")
  Result$POS <- as.numeric(Result$POS)
  Result$Zprime_Bulk <- as.numeric(Result$Zprime_Bulk)
  Result$Zprime_Parent <- as.numeric(Result$Zprime_Parent)
  Result$Zprime_Int <- as.numeric(Result$Zprime_Int)
  
  Result
}
```

```{r, eval = FALSE}
#Test function with defaults
results.mean.weighted.30 <- WindowCB_meanweighted(Res_Z_Chr, 30)

#Plot to see
results.mean.weighted.30 %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes
load("Zs.Rdata")
rbind(Zs, Zprimes) -> WeightedMeanZStats.30

WeightedMeanZStats.30$CHROM <- factor(WeightedMeanZStats.30$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

save(WeightedMeanZStats.30, file = "WeightedMeanZStats30.Rdata")
```

Plotting weighted means function

```{r}
load("WeightedMeanZStats30.Rdata")

WeightedMeanZStats.30 %>%  ggplot(., aes(x = POS, y = Int, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("lightblue", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Interaction Z vs Zprime | Weighted Means w = 30")

WeightedMeanZStats.30 %>%  ggplot(., aes(x = POS, y = Bulk, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("violet", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Bulk Effect Z vs Zprime | Weighted Means w = 30")

WeightedMeanZStats.30 %>%  ggplot(., aes(x = POS, y = Parent, color = Stat)) + geom_point(alpha = 0.3) + #geom_line() + 
  ylim(-10, 10) +  scale_color_manual(values = c("darkorange", "black")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Parent Effect Z vs Zprime | Weighted Means w = 30")

WeightedMeanZStats.30 %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + geom_hline(yintercept = 0, color = "gray")+
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Weighted Means w = 30")
```

## Figuring out a good statistical cutoff

Two options: FDR (empirical) or adjusted p-value. Since there's 97206 observations, the p-value by bonferroni correction would be 0.05^92k, which is probably a lot...?

First, z-score at p = 0.05 is 1.96; cutoffs drawn below:

```{r}
WeightedMeanZStats.30 %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Weighted Means")

```

## Trying new window sizes

```{r}
results.mean.weighted.100 <- WindowCB_meanweighted(Res_Z_Chr, 100)

#Plot to see
results.mean.weighted.100 %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes
load("Zs.Rdata")
rbind(Zs, Zprimes) -> WeightedMeanZStats.100

WeightedMeanZStats.100$CHROM <- factor(WeightedMeanZStats.100$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

WeightedMeanZStats.100 %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Weighted Means W = 100")

```

## What about a larger window for medians?

```{r}

results.median.weighted.100 <- WindowCB_beta(Res_Z_Chr, 100)

#Plot to see
results.median.weighted.100 %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes
load("Zs.Rdata")
rbind(Zs, Zprimes) -> MedianZStats.100

MedianZStats.100$CHROM <- factor(MedianZStats.100$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

MedianZStats.100 %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Medians W = 100")

```

```{r}
results.mean.weighted.10 <- WindowCB_beta(Res_Z_Chr, 10)

#Plot to see
results.mean.weighted.10 %>% transmute(CHROM = CHROM, POS = POS, Bulk = Zprime_Bulk, Parent = Zprime_Parent, Int = Zprime_Int, Stat = "ZPrime") -> Zprimes
load("Zs.Rdata")
rbind(Zs, Zprimes) -> WeightedMeanZStats.10

WeightedMeanZStats.10$CHROM <- factor(WeightedMeanZStats.10$CHROM,
                              levels = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", 
                                       "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "M"))

WeightedMeanZStats.10 %>% filter(Stat == "ZPrime") %>% pivot_longer(c("Bulk", "Parent", "Int")) %>% 
  ggplot(., aes(x = POS, y = value, color = name)) + geom_line(size = 1) + #geom_point(alpha = 0.1) + #
  scale_color_manual(values = c("violet", "lightblue", "darkorange")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Zprime per Factor | Medians W = 10")
```

## Comparing window sizes

How do each of the values change? Lower window sizes allow for the peaks to not be the entire chromosome, but the noise in the parental and interaction effects that are not significant are higher then. Still using the z = 1.96 cutoff until figuring out the correction.

```{r, eval = FALSE}
WeightedMeanZStats.10$Window <- "WeightedMean.10"
WeightedMeanZStats.100$Window <- "WeightedMean.100"
WeightedMeanZStats.30$Window <- "WeightedMean.30"

MedianZStats.100$Window <- "Median.100"

unique(MedianZStats.100$Stat)

WindowComp <- rbind(MedianZStats.100, WeightedMeanZStats.10, WeightedMeanZStats.30, WeightedMeanZStats.100) %>% filter(Stat == "ZPrime")

save(WindowComp, file = "WindowComparison.Rdata")
```

```{r}
load("WindowComparison.Rdata")

WindowComp %>% filter(CHROM == "VIII") %>% ggplot(., aes(x = POS, y = Bulk, color = Window)) + geom_line(size = 1, alpha = 0.5) +
  scale_color_manual(values = c("red", "cyan", "blue", "purple")) + 
  #scale_color_manual(values = c("purple", "gold", "red", "darkorange")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Window Sizes | Bulk Effect")

WindowComp %>% ggplot(., aes(x = POS, y = Parent, color = Window)) + geom_line(size = 1, alpha = 0.5) +
  scale_color_manual(values = c("red", "cyan", "blue", "purple")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Window Sizes | Parent Effect")

WindowComp %>% ggplot(., aes(x = POS, y = Int, color = Window)) + geom_line(size = 1, alpha = 0.5) +
  scale_color_manual(values = c("red", "cyan", "blue", "purple")) + 
  geom_hline(yintercept = 0, color = "gray") +
  geom_hline(yintercept = c(1.96, -1.96), color = "black", linetype = "dashed") +
  theme(axis.text.x = element_blank()) +
  facet_grid(~CHROM, scales = "free") + ggtitle("Comparison of Window Sizes | Interaction Effect")
```

